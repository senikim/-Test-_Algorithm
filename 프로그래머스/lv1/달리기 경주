
# [Trial & Error 1]
def solution(players, callings):
    answer = []
    rank = []

    for i in range(len(players)):
      rank.append(i)
    print(rank)
    for g in range(len(callings)):
      #print(rank[players.index(callings[g])])
      rank[players.index(callings[g])] = rank[players.index(callings[g])]-1
      rank[players.index(callings[g])-1] = rank[players.index(callings[g])-1]+1
      print(rank)

# 출력
# [0, 1, 2, 3, 4] -> rank : 등수 나열
# [0, 1, 3, 2, 4] -> 여기까진 'kai'가 한 등수 오르고, 'kai' 앞에 있던(원래 3등이었던)애가 한 등수 내려감
# [0, 1, 4, 1, 4] -> **여기서부터 error** 'kai'가 1등이 되긴 했는데 rank==1인 애 말고 그냥 'kai' 앞에 있는 애 rank만 늘어남
# [0, 1, 4, 2, 3]
# [0, 1, 4, 3, 2]

'''
[Trial]
- players의 인덱스를 따와서 '등수' 딕셔너리->리스트 만듦 (처음엔 딕셔너리로 하려다가 리스트로 바꿔서 해봄)

- callings 리스트 안에 있는 원소가 나올 때마다 '등수'배열에 있는 원소의 인덱스 -1 하고
  반대로 원래 그 자리에 있던 원소의 인덱스는 +1 하려고 함.

[Error]
- 원래 등수에 있던 원소를 찾게 하는 코드를 유기적으로 설계하지 못함.

- 'calling 리스트 안에 있는 원소 앞에 있던(리스트 기준 왼쪽에 위치한) 원소'를 '원래 등수에 있던 원소' 라고 설정했는데,
  그러면 반복되는 calling 값은 연산이 중복됨 (당연함.....)
'''
